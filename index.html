<!doctype html>
<html lang=en-US>
<meta charset=utf-8>
<title>URL parser testers</title>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0/dist/css/bootstrap.min.css" rel=stylesheet integrity=sha384-wEmeIV1mKuiNpC+IOBjI7aAzPcEZeedi5yW5f2yOq55WWLwNGmvvx4Um1vskeMj0 crossorigin=anonymous>
<meta name="author" content="Timothy Gu <timothygu99@gmail.com>">

<style>
#output tr.fail {
  outline: 2px solid var(--bs-danger);
}

#output td {
  font-family: var(--bs-font-monospace);
  word-break: break-word;
}

#output tbody tr {
  width: 150px;
}

#output td+td{
  width: auto;
}

#output td.empty-string {
  font-family: inherit;
  font-size: smaller;
  font-style: italic;
  color: #888;
  word-break: inherit;
}

#output td.fail {
  font-family: inherit;
  background-color: var(--bs-danger);
  color: white;
  word-break: inherit;
}

#output td.non-string {
  font-family: inherit;
  font-style: italic;
  word-break: inherit;
}

.fluid-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(max(40ch, 40%), 1fr));
  gap: 10px;
  grid-auto-flow: row dense;
}

.table-centered {
  width: auto;
  margin-left: auto;
  margin-right: auto;
}

@media (max-width: 767.98px) {
  .table-responsive {
    font-size: 0.95em;
  }
  /* Same as .table-sm. */
  .table-responsive > :not(caption) > * > * {
    padding: .25rem .25rem;
  }
}
</style>

<header style="float: right; text-align: right; padding: 1em 1em 0 0;">
  <a href="https://github.com/TimothyGu/urltester/blob/main/LICENSE.md">MIT-licensed</a><br>
  <a href="https://github.com/TimothyGu/urltester">Fork me on GitHub!</a>
</header>
<main>
  <div class=container>
    <h1>URL parser tester</h1>
    <p>
      This page parses a given URL with several available parsers, and compares
      their outputs. To support a variety of programming languages, we make
      heavy use of WebAssembly. Unfortunately, this may lead to some
      <strong>random crashes/reloads on Safari</strong>; Firefox and
      Chromium-based browsers are preferred.
    </p>
    <form>
      <label>URL to parse: <input type=text id=input value="https://timothygu.me/"></label>
      <label>Base URL: <input type=text id=base></label>
    </form>
  </div>
  <div class=container-xl>
    <table id=output class="table table-responsive">
      <thead>
        <tr>
          <td></td>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>
  <div class=container>
    <h2>Detailed methodology</h2>
    <p>
      Parsers sometimes have different names for the same part of a URL. Here, we
      made things consistent by using names used in the <abbr
      title="Web Hypertext Application Technology Working Group">WHATWG</abbr> <a
      href="https://url.spec.whatwg.org/#url"><code>URL</code> API</a>, available
      in browsers and Node.js. This translation may not always be exact; below we
      document how we figured the output of each parser.
    </p>
    <dl class=fluid-grid>
      <div>
        <dt>libcurl</dt>

        <dd>
          This is libcurl's <a href="https://everything.curl.dev/libcurl/url">URL
          API</a>. curl uses <a
          href="https://www.rfc-editor.org/rfc/rfc3986.html">RFC 3986</a> as
          the basis for its parser, with some features of the <abbr
          title="Web Hypertext Application Technology Working Group">WHATWG</abbr>
          URL Standard mixed in, as detailed on its <a
          href="https://curl.se/docs/url-syntax.html">URL Syntax</a> documentation page.
          We created a simple C application "frontend" for the API and compiled
          it to WebAssembly using Emscripten. While curl does <a
          href="https://curl.se/docs/url-syntax.html#idna">support</a>
          <abbr title="Internationalized Domain Names for Applications">IDNA</abbr>
          through the libidn2 library, the functionality is not exposed through
          the URL API.
        </dd>

        <dd>
          When parsing the URL, we use <code>CURLU_<wbr>NON_<wbr>SUPPORT_<wbr>SCHEME</code>
          and <code>CURLU_<wbr>URLENCODE</code> flags. When getting individual
          parts of the URL, we pass <code>0</code> as flags. The part mappings
          are as follows:
          <table class="table table-sm table-centered">
            <thead>
              <tr>
                <th>Property</th>
                <th><a href="https://github.com/curl/curl/blob/curl-7_76_1/include/curl/urlapi.h#L53-L65">CURLUPart</a></th>
              </tr>
            </thead>
            <tbody>
              <tr><td>href<td>CURLUPART_URL
              <tr><td>protocol<td>CURLUPART_SCHEME
              <tr><td>username<td>CURLUPART_USER
              <tr><td>password<td>CURLUPART_PASSWORD
              <tr><td>hostname<td>CURLUPART_HOST
              <tr><td>port<td>CURLUPART_PORT
              <tr><td>pathname<td>CURLUPART_PATH
              <tr><td>search<td>CURLUPART_QUERY
              <tr><td>hash<td>CURLUPART_FRAGMENT
            </tbody>
          </table>
          Note: We ignore <code>CURLUPART_<wbr>OPTIONS</code>, <a
          href="https://curl.se/docs/url-syntax.html#userinfo">used</a> for
          IMAP/<wbr>POP3/<wbr>SMTP "login options." We also do not list
          <code>CURLUPART_<wbr>ZONEID</code> separately as it is included in
          <code>CURLUPART_<wbr>HOST</code>.
        </dd>
      </div>
      <div>
        <dt>Go net/url</dt>
        <dt>Go net/http</dt>

        <dd>
          This is Go's built-in <a href="https://golang.org/pkg/net/url/">net/url
          package</a>. The parser is based on <a
          href="https://www.rfc-editor.org/rfc/rfc3986.html">RFC 3986</a>, with
          some compatibility fixes. We compiled it to WebAssembly using Go's <a
          href="https://github.com/golang/go/wiki/WebAssembly">built-in compiler
          support</a>. net/url itself does not support <abbr
          title="Internationalized Domain Names for Applications">IDNA</abbr>,
          but the built-in <a href="https://golang.org/pkg/net/http/">net/http
          package</a> does through the <a
          href="https://pkg.go.dev/golang.org/x/net/idna">golang.org/<wbr>x/<wbr>net/<wbr>idna
          package</a>. We added a "Go net/http" entry to emulate how net/http
          handles a URL.

        <dd>
          The part mappings are as follows:
          <table class="table table-sm table-centered">
            <thead>
              <tr>
                <th>Property</th>
                <th><a href="https://golang.org/pkg/net/url/#URL">url.URL</a> field/method</th>
              </tr>
            </thead>
            <tbody>
              <tr><td>href<td>String()
              <tr><td>protocol<td>Scheme
              <tr><td>username<td>User.Username()
              <tr><td>password<td>User.Password()
              <tr><td>hostname<td>Hostname()
              <tr><td>port<td>Port()
              <tr><td>pathname<td>EscapedPath() or Opaque
              <tr><td>search<td>RawQuery
              <tr><td>hash<td>EscapedFragment()
            </tbody>
          </table>
        </dd>
      </div>
      <div>
        <dt>spec-url</dt>
        <dt>spec-url absolute</dt>

        <dd>
          This is the JavaScript <a
          href="https://github.com/alwinb/spec-url">spec-url</a> library, a
          reference implementation of Alwin Blok's <a
          href="https://alwinb.github.io/url-specification/">URL
          Specification</a>. Blok's specification is designed to be a
          rephrasing of the <abbr
          title="Web Hypertext Application Technology Working Group">WHATWG</abbr>
          URL Standard in more theoretic terms. We used Browserify to generate
          a standalone bundle for the library.
        </dd>

        <dd>
          The <em>absolute</em> variant optimizes for use of the input string
          as an "absolute URL," at the risk of losing some information.
          Concretely, the absolute variant always <a
          href="https://alwinb.github.io/url-specification/#reference-resolution">forces</a>
          the parser output. The absolute variant is closer to how the <abbr
          title="Web Hypertext Application Technology Working Group">WHATWG</abbr>
          URL Standard operates, while the normal variant is closer to how Go's
          net/url operates.
        </dd>

        <dd>
          The part mappings are derived from Blok's specification:
          <table class="table table-sm table-centered">
            <thead>
              <tr>
                <th>Property</th>
                <th>Field/function</th>
              </tr>
            </thead>
            <tbody>
              <tr><td>href<td>print()
              <tr><td>protocol<td>scheme
              <tr><td>username<td>username
              <tr><td>password<td>password
              <tr><td>hostname<td>host
              <tr><td>port<td>port
              <tr><td>pathname<td>root + (dirs &amp;&amp; (dirs.join(/) + /)) + file
              <tr><td>search<td>query
              <tr><td>hash<td>hash
            </tbody>
          </table>
        </dd>
      </div>
      <div>
        <dt>Rust url</dt>

        <dd>
          This is Rust's <a href="https://docs.rs/url/">url</a> crate, created by
          the Servo Project. It should be highly compatible with the <abbr
          title="Web Hypertext Application Technology Working Group">WHATWG</abbr>
          URL Standard, and has complete <abbr
          title="Internationalized Domain Names for Applications">IDNA</abbr>
          support. We compiled it to WebAssembly using <a
          href="https://rustwasm.github.io/wasm-pack/">wasm-pack</a> and <a
          href="https://rustwasm.github.io/docs/wasm-bindgen/">wasm-bindgen</a>.
        </dd>

        <dd>
          The part mappings are as follows:
          <table class="table table-sm table-centered">
            <thead>
              <tr>
                <th>Property</th>
                <th><a href="https://docs.rs/url/2.2.1/url/struct.Url.html">url::Url</a> method</th>
              </tr>
            </thead>
            <tbody>
              <tr><td>href<td>as_str()
              <tr><td>protocol<td>scheme()
              <tr><td>username<td>username()
              <tr><td>password<td>password()
              <tr><td>hostname<td>host_str()
              <tr><td>port<td>port()
              <tr><td>pathname<td>path()
              <tr><td>search<td>query()
              <tr><td>hash<td>fragment()
            </tbody>
          </table>
        </dd>
      </div>
      <div>
        <dt>whatwg-url</dt>

        <dd>
          This is the JavaScript <a
          href="https://github.com/jsdom/whatwg-url">whatwg-url</a> library,
          designed from scratch to be a reference implementation of the <abbr
          title="Web Hypertext Application Technology Working Group">WHATWG</abbr>
          URL Standard. We load the latest (nightly) bundle of the JavaScript <a
          href="https://github.com/jsdom/whatwg-url">whatwg-url</a> library,
          which is also used for its own <a
          href="https://jsdom.github.io/whatwg-url/">URL Viewer</a> program. This
          utility is, to a large extent, inspired by URL Viewer. URL part mapping
          is trivial, as whatwg-url exposes the same properties as a browser
          <code>URL</code> object.
        </dd>
      </div>
      <div>
        <dt>your browser</dt>

        <dd>
          For comparison, we also parse every URL with your own browser's
          <code>URL</code> class. URL part mapping is trivial, as whatwg-url
          exposes the same properties as a browser <code>URL</code> object.
        </dd>
      </div>
    </dl>
  </div>
</main>

<script>
  class URLParser extends EventTarget {
    constructor(href) {
      super();
      this.href = href;
      this.nextID = 1;
      this.start();
      this.givenUp = false;

      this.lastInput = undefined;
      this.lastBase = undefined;
      this.lastOutputPromise = undefined;
    }

    start() {
      this.dispatchEvent(new CustomEvent("initializing"));

      let onInitialized;
      this.initialized = false;
      this.ready = new Promise(resolve => {
        onInitialized = resolve;
      });
      this.ready.then(() => {
        this.initialized = true;
        this.dispatchEvent(new CustomEvent("initialized"));
      });

      this.worker = new Worker(this.href);
      this.promiseResolvers = new Map();
      this.worker.onmessage = e => {
        const payload = e.data;
        if (!payload || !payload.id || !payload.type) {
          console.error(this.href, "received invalid payload from worker", payload);
          return;
        }

        switch (payload.type) {
          case "initialized":
            onInitialized();
            return;
          case "error":
            console.error(this.href, "received error", payload.err);
            if (payload.shouldRestart) {
              this.restart(payload.err);
            } else {
              console.error(this.href, "giving up")
              this.givenUp = true;
              this.stop(payload.err);
            }
            return;
          case "parsedURL":
            const promiseResolver = this.promiseResolvers.get(payload.orig);
            this.promiseResolvers.delete(payload.orig);
            if (!promiseResolver) {
              console.error(this.href, "No promise resolver found");
              return;
            }
            const [promise, resolve, reject, input, base] = promiseResolver;
            if (payload.err !== undefined) {
              payload.err.output = payload.output;
              payload.err.version = payload.version;
              reject(payload.err);
            } else {
              resolve(payload);
            }
            this.lastInput = input;
            this.lastBase = base;
            this.lastOutputPromise = promise;
            break;
          case "ignore":
            break;
          default:
            console.error(this.href, "received invalid payload (unrecognized type)", payload);
            return;
        }
      };
    }

    stop(ex) {
      for (const [promise, resolve, reject] of this.promiseResolvers.values()) {
        reject(ex);
      }
      this.worker.terminate();
      this.dispatchEvent(new CustomEvent("failed"));
    }

    restart(ex) {
      console.warn(this.href, "restarting worker");
      this.stop(ex);
      this.start();
    }

    async run(input, base) {
      if (input === this.lastInput && base === this.lastBase) {
        try {
          return await this.lastOutputPromise;
        } catch {}
      }

      const id = this.nextID++;
      this.worker.postMessage({
        id,
        type: "urlToParse",
        input,
        base,
      });
      let resolve, reject;
      const prom = new Promise((rs, rj) => {
        resolve = rs;
        reject = rj;
      });
      this.promiseResolvers.set(id, [prom, resolve, reject, input, base]);
      return prom;
    }
  }

  const inputEl = document.getElementById("input");
  const baseEl = document.getElementById("base");
  const outputEl = document.getElementById("output");

  const props = [
    "href", "protocol", "username", "password",
    "hostname", "port", "pathname", "search",
    "hash",
  ];
  for (const prop of props) {
    const tbody = outputEl.tBodies[0];
    const row = document.createElement("tr");
    row.setAttribute("data-prop", prop);
    const th = document.createElement("th");
    th.textContent = prop;
    th.setAttribute("scope", "row");
    row.append(th);
    tbody.append(row);
  }

  class ParserRenderer {
    constructor(name, href, index) {
      this.name = name;
      this.href = href;
      this.index = index;
      this.parser = new URLParser(href);

      const thead = outputEl.tHead;
      const row = thead.rows[0];
      let th = row.cells[index + 1];
      if (!th) {
        while (row.cells.length < index + 2) {
          th = document.createElement("th");
          row.append(th);
        }
      }

      if (this.parser.initialized) {
        th.innerText = name + "\ninitializing";
      } else {
        th.innerText = name;
      }

      this.version = "";

      this.updateTh = () => {
        let nameAndVersion = name;
        if (this.version) {
          nameAndVersion += ` (${this.version})`;
        }
        if (this.parser.givenUp) {
          th.innerText = nameAndVersion + "\nfailed";
        } else if (this.parser.initialized) {
          th.innerText = nameAndVersion;
        } else {
          th.innerText = nameAndVersion + "\ninitializing";
        }
      };

      this.parser.addEventListener("initializing", this.updateTh);
      this.parser.addEventListener("initialized", this.updateTh);
      this.parser.addEventListener("failed", this.updateTh);
    }

    async run(input, base) {
      if (this.parser.givenUp) {
        return "failed to start";
      } else if (!this.parser.initialized) {
        return "initializing";
      }
      try {
        const out = await this.parser.run(input, base);
        if (out.version) {
          this.version = out.version;
          this.updateTh();
        }
        if (!out.json) {
          throw new Error(JSON.stringify(out));
        }
        return props.map(prop => out.json[prop]);
      } catch (err) {
        if (err.version) {
          this.version = err.version;
          this.updateTh();
        }
        return err?.message || err;
      }
    }
  }

  const parsers = new Map([
    ["libcurl", "curl/worker.js"],
    ["Go net/url", "go/url/worker.js"],
    ["Go net/http", "go/http/worker.js"],
    ["spec-url", "spec-url/worker.js"],
    ["spec-url absolute", "spec-url/worker-absolute.js"],
    ["Rust url", "rust/urltest/worker.js"],
    ["whatwg-url", "whatwg-url/worker.js"],
    ["your browser", "native/worker.js"],
  ]);

  const renders = [];
  for (const [name, href] of parsers) {
    const render = new ParserRenderer(name, href, renders.length);
    renders.push(render);
  }

  async function runAndUpdate() {
    const input = inputEl.value;
    const base = baseEl.value || undefined;

    const boxes = await Promise.all(renders.map(render => render.run(input, base)));

    let skipped = 0;
    for (const box of boxes) {
      if (!Array.isArray(box)) {
        skipped++;
      }
    }

    const tbody = outputEl.tBodies[0];
    for (let i = 0; i < tbody.rows.length; i++) {
      const row = tbody.rows[i];
      let j = 1;
      let last = undefined;
      let mismatch = false;
      for (const col of boxes) {
        let str;
        if (!Array.isArray(col)) {
          if (i !== 0) {
            continue;
          }
          str = String(col);
        } else {
          str = col[i];
          if (!mismatch) {
            if (last === undefined) {
              last = str;
            } else if (last !== str) {
              mismatch = true;
            }
          }
        }

        let td = row.cells[j];
        if (!td) {
          while (row.cells.length <= j) {
            td = document.createElement("td");
            row.append(td);
          }
        }

        if (!Array.isArray(col)) {
          td.innerText = str;
          td.className = "fail";
          td.setAttribute("rowspan", props.length);
        } else if (str === "") {
          td.innerText = "(empty string)";
          td.className = "empty-string";
          td.removeAttribute("rowspan");
        } else if (typeof str === "string") {
          td.innerText = str;
          td.removeAttribute("class");
          td.removeAttribute("rowspan");
        } else {
          td.innerText = str;
          td.className = "non-string";
          td.removeAttribute("rowspan");
        }

        j++;
      }

      while (j < row.cells.length) {
        row.removeChild(row.cells[j]);
      }

      if (mismatch) {
        row.className = "fail";
      } else {
        row.removeAttribute("class");
      }
    }
  }

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds.
  // From https://gist.github.com/nmsdvid/8807205
  function debounce(func, wait) {
    let timeout;
    return function(...args) {
      clearTimeout(timeout);
      timeout = setTimeout(() => {
        timeout = null;
        func.apply(this, args);
      }, wait);
    };
  }

  const debouncedRunAndUpdate = debounce(runAndUpdate, 200);

  runAndUpdate();
  inputEl.addEventListener("input", debouncedRunAndUpdate);
  baseEl.addEventListener("input", debouncedRunAndUpdate);

  for (const render of renders) {
    render.parser.ready.then(debouncedRunAndUpdate);
  }
</script>
